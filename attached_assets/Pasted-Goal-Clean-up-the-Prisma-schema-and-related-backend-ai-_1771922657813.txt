Goal: Clean up the Prisma schema and related backend/ai-service code in two areas: (1) simplify the field model by keeping one column and removing three, and (2) align the Comment and AI models with project conventions (naming, singular/plural, no bad defaults, and String IDs with cuid like Space and Base). Apply everything below; field cleanup and the four-table cleanup are independent.
Scope of changes: All schema changes (field model and Comment + AI tables) must be reflected across the stack. Update the frontend, backend, and all relevant endpoints so they use the new Prisma model names, field names (camelCase in code, snake_case in DB where applicable), and ID types (String cuid for Comment and AI). No callers should keep using removed columns (field.order, field.enrichment, field.hasError), old snake_case field names, or integer IDs for Comment/AI. Update API contracts, DTOs, and any raw SQL or client code that references these models or columns.
Conventions (use everywhere): Prisma model names = singular PascalCase. Table names = plural, via @@map("..."). Prisma field names = camelCase. DB column names = snake_case via @map("snake_case"). Timestamps in Prisma = createdTime / lastModifiedTime (or updatedAt) with appropriate @map. Use @updatedAt where the column should be auto-updated on change. IDs: Use String with @default(cuid()) and @map("id") for all primary and foreign keys in the Comment and AI models, matching the pattern used in Space and Base (no integer autoincrement).
Functionality 1 – Field model
Keep: The lookup_options column on the field model (e.g. lookupOptions Json? @map("lookup_options")). Keep this column and all code that reads or writes it.
Remove (do all three):
order – Remove the order column from the field model in prisma/schema.prisma if it exists. Column order is only at the view level (View.columnMeta). Backend uses view.getFieldOrder, view.setFieldOrder, and view.getHighestOrderOfColumn. Find and remove or revert any code that reads or writes field.order (or a mapped order column on the field table) so ordering is driven only by the view’s columnMeta. Update frontend, backend, and any endpoints that send or expect field order so they use only view/columnMeta for order.
enrichment – Remove the enrichment column from the field model if it exists. Enrichment config lives in field.options. Find and remove or revert any code that reads or writes field.enrichment (or a mapped enrichment column) so enrichment config uses only field.options. Update frontend, backend, and any endpoints that read or write enrichment so they use only field.options.
has_error – Remove the has_error column from the field model if it exists (e.g. hasError Boolean @map("has_error")). Error state is only in field.computedFieldMeta (e.g. computedFieldMeta.hasError). Find and remove or revert any code that reads or writes a top-level field.hasError / field.has_error (or mapped has_error) so error state is only via field.computedFieldMeta. Update frontend, backend, and any endpoints that rely on field error state so they use only computedFieldMeta.
Functionality 2 – Comment model (comments table)
Goal: One singular model, camelCase fields, explicit @map to DB, and String id with cuid (no nextval, no integer autoincrement).
Model and table: Model name Comment (singular). Table name plural via @@map("comments") or @@map("__comments") depending on whether the DB table is comments or __comments.
ID: id String @id @default(cuid()) @map("id") — same pattern as Space and Base. Remove any use of nextval('__comments_id_seq'::regclass) or integer autoincrement.
Fields: In Prisma use camelCase and map to snake_case: tableId @map("table_id"), recordId @map("record_id"), parentId @map("parent_id") (String, FK to Comment.id if self-relation), userId @map("user_id"), userName @map("user_name"), userAvatar @map("user_avatar"), createdTime @map("created_at"), lastModifiedTime @map("updated_at"), deletedTime @map("deleted_at"). Self-relation: e.g. parentComment / replies with parentId and references: [id]; parentId type String? to match Comment.id.
Frontend, backend, endpoints: Update all comment APIs, DTOs, and frontend code to use the new model (e.g. prisma.comment), camelCase field names (tableId, recordId, parentId, userId, etc.), and String comment IDs (cuid). Ensure request/response payloads and types use the same naming and id type.
Functionality 3 – AI conversation model (ai_conversations table)
Goal: Singular model, camelCase fields, no hardcoded user default, context columns as baseId, tableId, viewId, and String id with cuid.
Model and table: Model name AiConversation (singular). Table name ai_conversations via @@map("ai_conversations").
ID: id String @id @default(cuid()) @map("id") — same as Space and Base. No integer autoincrement.
User: userId (camelCase, @map("user_id")). Remove any default (e.g. do not use @default("dev-user-001")). userId must be set from auth in application code only.
Context columns: Use baseId, tableId, viewId in Prisma (not currentBaseId/currentTableId/currentViewId), with @map("base_id"), @map("table_id"), @map("view_id").
Other: title can keep a default e.g. @default("New Chat"). Timestamps: createdTime and lastModifiedTime (or updatedAt) with @map("created_at") and @map("updated_at"), and @updatedAt on the updated-at column.
Frontend, backend, ai-service, endpoints: Update all conversation APIs (backend and ai-service), DTOs, and frontend to use the new model (e.g. prisma.aiConversation), camelCase fields (userId, baseId, tableId, viewId, createdTime, lastModifiedTime), and String conversation IDs (cuid). Update raw SQL in ai-service to use the new column names and id type.
Functionality 4 – AI message model (ai_messages table)
Goal: Singular model, camelCase fields, correct relation to conversation, and String ids with cuid.
Model and table: Model name AiMessage (singular). Table name ai_messages via @@map("ai_messages").
ID: id String @id @default(cuid()) @map("id") — same as Space and Base. No integer autoincrement.
FK: conversationId String @map("conversation_id") — references AiConversation.id (String).
Other fields: role, content, actionType @map("action_type"), actionPayload @map("action_payload"), createdTime @map("created_at"), feedback. Relation: conversation → AiConversation.
Frontend, backend, ai-service, endpoints: Update all message APIs, DTOs, and frontend to use the new model (e.g. prisma.aiMessage), camelCase fields, and String message and conversation IDs (cuid). Update raw SQL in ai-service accordingly.
Functionality 5 – AI approved context model (ai_approved_contexts table)
Goal: Singular model, camelCase fields, String ids with cuid; stores approved base/table per conversation.
Model and table: Model name AiApprovedContext (singular). Table name ai_approved_contexts via @@map("ai_approved_contexts").
ID: id String @id @default(cuid()) @map("id") — same as Space and Base. No integer autoincrement.
FK: conversationId String @map("conversation_id") — references AiConversation.id (String).
Fields: baseId @map("base_id"), tableId @map("table_id") (optional), approvedTime or approvedAt @map("approved_at"). Relation: conversation → AiConversation.
Constraint: Keep uniqueness on (conversationId, baseId, tableId) via @@unique([conversationId, baseId, tableId]).
Frontend, backend, ai-service, endpoints: Update all approved-context APIs and ai-service raw SQL to use the new model and camelCase fields, and String ids (cuid).
Execution: Apply Functionality 1 (field) and Functionalities 2–5 (Comment + AI tables). Ensure all Comment and AI primary and foreign keys use String and cuid(); create a migration and update any raw SQL or code that assumes integer IDs. Update Prisma schema, run generate, then update frontend, backend, ai-service, and all necessary endpoints so they align with the schema: new model names, camelCase in code, snake_case in DB via @map, no use of removed field columns, and String cuid for Comment and AI. Update API contracts, DTOs, and client types so the full stack stays consistent with these schema changes.
