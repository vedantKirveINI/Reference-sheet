name: Issue ID Check

on:
  pull_request:
    types: [opened, synchronize, edited, reopened]
    branches:
      - develop

permissions:
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  check-issue-ids:
    runs-on: ubuntu-latest
    name: Check Issue IDs

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Extract Issue IDs from PR
        id: extract-issues
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          echo "üîç Checking for Issue IDs (pattern: T followed by numbers)..."

          # Extract Issue IDs from PR title
          echo "üìù PR Title: $PR_TITLE"
          TITLE_ISSUES=$(echo "$PR_TITLE" | grep -oE 'T[0-9]+' || true)

          # Extract Issue IDs from PR body/description
          echo "üìù PR Body:"
          echo "$PR_BODY"
          BODY_ISSUES=$(echo "$PR_BODY" | grep -oE 'T[0-9]+' || true)

          # Extract Issue IDs from all commit messages (including body)
          echo "üìù Commit Messages:"
          COMMIT_MESSAGES=$(git log --format="%B" $BASE_SHA..$HEAD_SHA 2>/dev/null || git log --format="%B" -n 20)
          echo "$COMMIT_MESSAGES"
          COMMIT_ISSUES=$(echo "$COMMIT_MESSAGES" | grep -oE 'T[0-9]+' || true)

          # Combine all Issue IDs and remove duplicates
          ALL_ISSUES=$(echo -e "$TITLE_ISSUES\n$BODY_ISSUES\n$COMMIT_ISSUES" | grep -E '^T[0-9]+$' | sort -u | tr '\n' ' ' | xargs)

          echo "üìã Found Issue IDs: $ALL_ISSUES"

          if [ -z "$ALL_ISSUES" ]; then
            echo "‚ùå No Issue IDs found!"
            echo "issue_ids=" >> $GITHUB_OUTPUT
            echo "has_issues=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found Issue IDs: $ALL_ISSUES"
            echo "issue_ids=$ALL_ISSUES" >> $GITHUB_OUTPUT
            echo "has_issues=true" >> $GITHUB_OUTPUT
          fi

      - name: ‚ùå Fail if no Issue IDs found
        if: steps.extract-issues.outputs.has_issues == 'false'
        run: |
          echo "::error::No Issue IDs found in PR title, body, or commit messages."
          echo "Please include at least one Issue ID (format: T followed by numbers, e.g., T1263) in:"
          echo "  - PR title"
          echo "  - PR description/body"
          echo "  - Commit message (including body)"
          exit 1

      - name: üîó Verify Issue IDs exist in Teable
        if: steps.extract-issues.outputs.has_issues == 'true'
        id: verify-issues
        env:
          TEABLE_API_TOKEN: ${{ secrets.APP_TEABLE_AI_TOKEN }}
          ISSUE_IDS: ${{ steps.extract-issues.outputs.issue_ids }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          echo "üîó Verifying Issue IDs in Teable: $ISSUE_IDS"

          # Build filter for multiple Issue IDs
          FILTER_SET=""
          for ISSUE_ID in $ISSUE_IDS; do
            if [ -n "$FILTER_SET" ]; then
              FILTER_SET="$FILTER_SET,"
            fi
            FILTER_SET="$FILTER_SET{\"fieldId\":\"Issue_ID\",\"operator\":\"is\",\"value\":\"$ISSUE_ID\"}"
          done

          FILTER="{\"conjunction\":\"or\",\"filterSet\":[$FILTER_SET]}"
          ENCODED_FILTER=$(echo "$FILTER" | jq -sRr @uri)

          echo "üì§ Querying Teable API..."

          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET \
            "https://app.teable.ai/api/table/tblNHimLUhUDtC3K7Jk/record?fieldKeyType=dbFieldName&viewId=viwBK7iTy1604XbFdYh&filter=$ENCODED_FILTER" \
            -H "Authorization: Bearer $TEABLE_API_TOKEN" \
            -H "Accept: application/json")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "üì• API Response Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Failed to query Teable API. HTTP Code: $HTTP_CODE"
            echo "Response: $BODY"
            exit 1
          fi

          # Check if records exist
          RECORD_COUNT=$(echo "$BODY" | jq '.records | length')
          echo "üìä Found $RECORD_COUNT matching records in Teable"

          if [ "$RECORD_COUNT" -eq 0 ]; then
            echo "::error::No matching Issue IDs found in Teable. Please ensure the Issue IDs ($ISSUE_IDS) exist."
            exit 1
          fi

          # Extract record IDs and their statuses for updating
          echo "$BODY" | jq -c '.records[] | {id: .id, status: .fields.status}' > /tmp/records.json

          RECORD_IDS=$(echo "$BODY" | jq -r '.records[].id')
          echo "record_ids<<EOF" >> $GITHUB_OUTPUT
          echo "$RECORD_IDS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "record_count=$RECORD_COUNT" >> $GITHUB_OUTPUT

          # Save full response for status checking
          echo "$BODY" > /tmp/teable_response.json

          echo "‚úÖ All Issue IDs verified successfully!"

      - name: üìù Update Teable records (Community_PR & Status)
        if: steps.extract-issues.outputs.has_issues == 'true' && steps.verify-issues.outputs.record_count > 0
        env:
          TEABLE_API_TOKEN: ${{ secrets.APP_TEABLE_AI_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          echo "üìù Updating Teable records..."

          # Status values that should be updated to "Entered development workflow"
          STATUSES_TO_UPDATE=("" "Need more information" "Added to backlog")

          # Read records from saved response
          cat /tmp/teable_response.json | jq -c '.records[]' | while read -r record; do
            RECORD_ID=$(echo "$record" | jq -r '.id')
            CURRENT_STATUS=$(echo "$record" | jq -r '.fields.status // ""')
            
            echo "Processing record: $RECORD_ID (current status: '$CURRENT_STATUS')"
            
            # Determine if status should be updated
            SHOULD_UPDATE_STATUS="false"
            for status in "${STATUSES_TO_UPDATE[@]}"; do
              if [ "$CURRENT_STATUS" == "$status" ]; then
                SHOULD_UPDATE_STATUS="true"
                break
              fi
            done
            
            # Build update payload
            if [ "$SHOULD_UPDATE_STATUS" == "true" ]; then
              echo "  ‚Üí Status will be updated to 'Entered development workflow'"
              UPDATE_PAYLOAD="{\"fieldKeyType\":\"dbFieldName\",\"record\":{\"fields\":{\"Community_PR\":\"$PR_URL\",\"status\":\"Entered development workflow\"}}}"
            else
              echo "  ‚Üí Status will not be changed (current: '$CURRENT_STATUS')"
              UPDATE_PAYLOAD="{\"fieldKeyType\":\"dbFieldName\",\"record\":{\"fields\":{\"Community_PR\":\"$PR_URL\"}}}"
            fi
            
            # Send update request
            UPDATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
              "https://app.teable.ai/api/table/tblNHimLUhUDtC3K7Jk/record/$RECORD_ID" \
              -H "Authorization: Bearer $TEABLE_API_TOKEN" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "$UPDATE_PAYLOAD")
            
            HTTP_CODE=$(echo "$UPDATE_RESPONSE" | tail -n1)
            BODY=$(echo "$UPDATE_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" != "200" ]; then
              echo "::warning::Failed to update record $RECORD_ID. HTTP Code: $HTTP_CODE"
              echo "Response: $BODY"
            else
              echo "‚úÖ Successfully updated record $RECORD_ID"
            fi
          done

          echo "‚úÖ Teable records update completed!"

      - name: üìù Append Issue IDs to PR description
        if: steps.extract-issues.outputs.has_issues == 'true' && steps.verify-issues.outputs.record_count > 0
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_IDS: ${{ steps.extract-issues.outputs.issue_ids }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          echo "üìù Checking if Issue IDs need to be appended to PR description..."

          # Create Issue IDs reference line
          ISSUE_IDS_LINE="**Related Issues:** $ISSUE_IDS"

          # Check if Issue IDs are already in the PR body
          ISSUES_ALREADY_IN_BODY="true"
          for ISSUE_ID in $ISSUE_IDS; do
            if ! echo "$PR_BODY" | grep -q "$ISSUE_ID"; then
              ISSUES_ALREADY_IN_BODY="false"
              break
            fi
          done

          # Check if the reference line already exists
          if echo "$PR_BODY" | grep -q "^\*\*Related Issues:\*\*"; then
            echo "‚úÖ Related Issues line already exists in PR description, skipping update"
            exit 0
          fi

          # If all Issue IDs are already in the body but not in the reference format, we still want to add the reference line
          # This ensures consistency and makes it easier to parse

          echo "üìù Appending Issue IDs to PR description..."

          # Append Issue IDs to PR body
          if [ -z "$PR_BODY" ]; then
            NEW_BODY="$ISSUE_IDS_LINE"
          else
            NEW_BODY="$PR_BODY

          ---
          $ISSUE_IDS_LINE"
          fi

          # Update PR description using GitHub CLI
          gh pr edit "$PR_NUMBER" --body "$NEW_BODY"

          echo "‚úÖ PR description updated with Issue IDs!"

      - name: ‚úÖ Check Complete
        if: steps.extract-issues.outputs.has_issues == 'true'
        run: |
          echo "‚úÖ Issue ID check completed successfully!"
          echo "üìã Verified Issue IDs: ${{ steps.extract-issues.outputs.issue_ids }}"
          echo "üîó PR URL and status updated in Teable records"
          echo "üìù Issue IDs appended to PR description for squash merge"
