import { inject, injectable } from '@teable/v2-di';
import { err, ok, safeTry } from 'neverthrow';
import type { Result } from 'neverthrow';

import type { BaseId } from '../../domain/base/BaseId';
import { domainError, type DomainError } from '../../domain/shared/DomainError';
import type { IDomainEvent } from '../../domain/shared/DomainEvent';
import type { LinkForeignTableReference } from '../../domain/table/fields/visitors/LinkForeignTableReferenceVisitor';
import type { Table } from '../../domain/table/Table';
import * as ExecutionContextPort from '../../ports/ExecutionContext';
import * as TableRepositoryPort from '../../ports/TableRepository';
import * as TableSchemaRepositoryPort from '../../ports/TableSchemaRepository';
import { v2CoreTokens } from '../../ports/tokens';
import { TraceSpan } from '../../ports/TraceSpan';
import { FieldCreationSideEffectService } from './FieldCreationSideEffectService';

export type TableCreationServiceInput = {
  /**
   * The base ID for the tables being created.
   */
  baseId: BaseId;

  /**
   * Built Table domain objects to persist.
   * Tables should already be validated.
   */
  tables: ReadonlyArray<Table>;

  /**
   * External/foreign tables referenced by the tables being created.
   * Used for field creation side effects (e.g., creating symmetric link fields).
   */
  externalTables: ReadonlyArray<Table>;

  /**
   * Foreign table references grouped by table index.
   * Used for determining table insertion order.
   */
  referencesByTable: ReadonlyArray<ReadonlyArray<LinkForeignTableReference>>;
};

export type TableCreationServiceResult = {
  /**
   * The persisted tables after insertion.
   */
  persistedTables: ReadonlyArray<Table>;

  /**
   * Table state including both created and external tables after side effects.
   */
  tableState: ReadonlyMap<string, Table>;

  /**
   * Events generated by field creation side effects.
   * These events are NOT published by the service; caller is responsible for publishing.
   */
  sideEffectEvents: ReadonlyArray<IDomainEvent>;
};

const isInternalReference = (
  ref: LinkForeignTableReference,
  baseId: BaseId,
  internalTableIds: ReadonlySet<string>
): boolean => {
  if (ref.baseId && !ref.baseId.equals(baseId)) return false;
  return internalTableIds.has(ref.foreignTableId.toString());
};

const sortTablesByForeignDependencies = (
  tables: ReadonlyArray<Table>,
  referencesByTable: ReadonlyArray<ReadonlyArray<LinkForeignTableReference>>,
  baseId: BaseId,
  internalTableIds: ReadonlySet<string>
): ReadonlyArray<Table> => {
  const entries = tables.map((table, index) => ({
    table,
    id: table.id().toString(),
    references: referencesByTable[index] ?? [],
  }));
  const idToIndex = new Map(entries.map((entry, index) => [entry.id, index] as const));
  const dependents = entries.map(() => new Set<number>());
  const inDegree = entries.map(() => 0);

  entries.forEach((entry, index) => {
    for (const ref of entry.references) {
      if (!isInternalReference(ref, baseId, internalTableIds)) continue;
      const depIndex = idToIndex.get(ref.foreignTableId.toString());
      if (depIndex === undefined || depIndex === index) continue;
      if (dependents[depIndex]!.has(index)) continue;
      dependents[depIndex]!.add(index);
      inDegree[index]! += 1;
    }
  });

  const queue = entries
    .map((_, index) => (inDegree[index] === 0 ? index : -1))
    .filter((index) => index >= 0);
  const sorted: number[] = [];

  while (queue.length > 0) {
    const current = queue.shift()!;
    sorted.push(current);
    for (const dependent of dependents[current]!) {
      inDegree[dependent]!--;
      if (inDegree[dependent] === 0) {
        queue.push(dependent);
      }
    }
  }

  if (sorted.length !== entries.length) {
    return tables;
  }

  return sorted.map((index) => entries[index]!.table);
};

/**
 * Application service for batch table creation.
 *
 * Responsibilities:
 * - Insert tables to TableRepository
 * - Create physical table structures (TableSchemaRepository)
 * - Process field creation side effects
 *
 * NOT responsible for:
 * - Transaction management (caller should wrap in a transaction)
 * - Record insertion
 * - Event publishing
 */
@injectable()
export class TableCreationService {
  constructor(
    @inject(v2CoreTokens.tableRepository)
    private readonly tableRepository: TableRepositoryPort.ITableRepository,
    @inject(v2CoreTokens.tableSchemaRepository)
    private readonly tableSchemaRepository: TableSchemaRepositoryPort.ITableSchemaRepository,
    @inject(v2CoreTokens.fieldCreationSideEffectService)
    private readonly fieldCreationSideEffectService: FieldCreationSideEffectService
  ) {}

  @TraceSpan()
  async execute(
    context: ExecutionContextPort.IExecutionContext,
    input: TableCreationServiceInput
  ): Promise<Result<TableCreationServiceResult, DomainError>> {
    const service = this;
    return safeTry<TableCreationServiceResult, DomainError>(async function* () {
      const { baseId, tables, externalTables, referencesByTable } = input;

      if (tables.length === 0) {
        return ok({
          persistedTables: [],
          tableState: new Map(externalTables.map((t) => [t.id().toString(), t] as const)),
          sideEffectEvents: [],
        });
      }

      const internalTableIds = new Set(tables.map((t) => t.id().toString()));

      // Sort tables by foreign dependencies for proper insertion order
      const sortedTables = sortTablesByForeignDependencies(
        tables,
        referencesByTable,
        baseId,
        internalTableIds
      );

      // Insert all tables
      const persistedTables = yield* await service.tableRepository.insertMany(
        context,
        sortedTables
      );

      // Create physical table structures
      yield* await service.tableSchemaRepository.insertMany(context, persistedTables);

      // Build initial table state
      let tableState = new Map<string, Table>();
      for (const table of externalTables) {
        tableState.set(table.id().toString(), table);
      }

      const persistedById = new Map(
        persistedTables.map((table) => [table.id().toString(), table] as const)
      );

      const orderedPersistedTables: Table[] = [];
      for (const table of tables) {
        const persistedTable = persistedById.get(table.id().toString());
        if (!persistedTable) {
          return err(domainError.notFound({ message: 'Persisted table not found' }));
        }
        orderedPersistedTables.push(persistedTable);
      }

      for (const table of orderedPersistedTables) {
        tableState.set(table.id().toString(), table);
      }

      // Process field creation side effects
      const sideEffectEvents: IDomainEvent[] = [];

      for (const table of sortedTables) {
        const persistedTable = persistedById.get(table.id().toString());
        if (!persistedTable) {
          return err(domainError.notFound({ message: 'Persisted table not found' }));
        }

        const sideEffectResult = yield* await service.fieldCreationSideEffectService.execute(
          context,
          {
            table: persistedTable,
            fields: persistedTable.getFields(),
            foreignTables: [...tableState.values()],
            tableState,
          }
        );
        sideEffectEvents.push(...sideEffectResult.events);
        tableState = new Map(sideEffectResult.tableState);
      }

      return ok({
        persistedTables: orderedPersistedTables,
        tableState,
        sideEffectEvents,
      });
    });
  }
}
